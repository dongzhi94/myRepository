1.请写出下面几个表达式的结果，答案可以用10进制或16进制书写
    1). 0xaa | 0x55
    2). 15 & 240
    3). 10 ^ 12
    4). -2 >> 1
    5). -2 >>> 1

    1). 分析：十六进制数用0x……来表示，后面一个十六进制位是四位，两个十六进制位为一个字节，最多后面可以有8个十六进制位，4个字节共32位,
    如：0xFFFFFFFF。 或（“ | ”）运算，全0为0，其他为1。
    所以：0xaa 用二进制表示为 10101010 ,0x55 用二进制表示为 01010101 ,按位或之后为 11111111 ，十进制数为255，十六进制数为 0xFF 。
    2). 分析：10进制转换成2进制，用该数字除以2，记录商和余数，利用商再次除以2，记录商和余数……直到商为0或余数为1停止，余数逆序组成二进制的从低到高位（最后的余数为二进制最低位）。与（“ & ”）运算，全1为1，其他为0 。
    所以： 15 等于1111 ，240等于 11110000，15前面用0补齐为00001111 ，按位与之后为 00000000 ，即结果为0
    3). 分析： 亦或（“ ^ ”）运算，相同取0，不同取1 。
    所以：1010 ^ 1100 =0110 , 十进制表示为6，十六进制表示为 0x06 。
    4). 分析： 带符号右移（“ >> ”），即有符号位时，负数符号位补1，正数符号位补0， -2 的二进制求法是正数取反加1，因此 2 的二进制表示为0000 0000 0000 0000 0000 0000 0000 0010 ，
    取反加一为 1111 1111 1111 1111 1111 1111 1111 1110 ，即 -2 的二进制表示。
    注： >> , << , >>> , 运算符只针对int型和long型，byte ,short ,char型需要转换成int型在进行操作。
    所以： 带符号右移之后为 1111 1111 1111 1111 1111 1111 1111 1111 ，除符号位之外，减一取反，得到带符号十进制数为 -1 。
    5). 分析：无符号右移 (“ >>> ”) ，即无论正负数，右移之后符号位均补 0 。
    所以： -2 的二进制无符号右移一位之后为 0111 1111 1111 1111 1111 1111 1111 1111，即 2^31 - 1,二的三十一次方减一。
    注：右移和无符号右移主要区别就在于左面最高位补 0 还是补 1 的问题，无符号右移任何时候最高位都补 0 ， 有符号右移则是正数补 0 ，负数补 1 。（没有无符号左移！）。

2.什么是值传递和引用传递？
    值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
    引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。
    一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 。

3.解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。
    通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；
    而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；
    方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；
    程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分。
    栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，
    栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

4.什么是迭代器(Iterator)？
    Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。
    迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

5.Iterator和ListIterator的区别是什么？
    下面列出了他们的区别：
    Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
    Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
    ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

6.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？
    快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。
    在java.util包下的都是快速失败。
    安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。
    在java.util.concurrent包下的全是安全失败的。

7.Java中的HashMap的工作原理是什么？
    我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，
    如下是它数据结构：最左侧是一个数组，数组中的每一个元素都是一个链表，链表的每一个元素都是entry。
    HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。

8.当两个对象的hashcode相同会发生什么？
    因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。

9.如果两个键的hashcode相同，你如何获取值对象？
    当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

10.ArrayList和Vector有何异同点？
    ArrayList和Vector在很多时候都很类似。
    （1）两者都是基于索引的，内部由一个数组支持。
    （2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。
    （3）ArrayList和Vector的迭代器实现都是fail-fast的。
    （4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。
    以下是ArrayList和Vector的不同点。
    （1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
    （2）ArrayList比Vector快，它因为有同步，不会过载。
    （3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。

11.Array和ArrayList有何区别？什么时候更适合用Array？
    Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
    Array是指定大小的，而ArrayList大小是固定的。
    Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，
    但也有些时候Array比较好用：
    （1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。
    （2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。
    （3）如果你要使用多维数组，使用[][]比List方便